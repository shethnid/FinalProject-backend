1. manage.py:
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


2. backend\asgi.py:
import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings")

application = get_asgi_application()


3. backend\settings.py:
from pathlib import Path
import os
from dotenv import load_dotenv

load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = "django-insecure-uzoi2e@e&@2-8ygdy9c%hdc67%&97o=hw1mkkz#pd9r0jg6vm1"

DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "corsheaders",
    "core.apps.CoreConfig",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "backend.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# CORS settings
CORS_ALLOW_ALL_ORIGINS = True  # for development!
# Add these settings below your existing CORS settings
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vite default port
]


CORS_ALLOW_HEADERS = [
    'accept',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
    'range',  # Important for PDF streaming
]

CORS_EXPOSE_HEADERS = ['content-length', 'content-range']

# Media files settings
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'


OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
OPENAI_MODEL = "gpt-4-1106-preview"  # or "gpt-4"

REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
}

4. backend\urls.py:
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("admin/", admin.site.urls),
    path('api/', include('core.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

5. backend\wsgi.py:
import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings")

application = get_wsgi_application()


6. backend\__init__.py:
(Empty file)

7. core\admin.py:
from django.contrib import admin
from .models import Document, Analysis, Conversation

@admin.register(Document)
class DocumentAdmin(admin.ModelAdmin):
    list_display = ('title', 'uploaded_at')
    search_fields = ('title',)
    list_filter = ('uploaded_at',)
    readonly_fields = ('uploaded_at',)

@admin.register(Analysis)
class AnalysisAdmin(admin.ModelAdmin):
    list_display = ('document', 'created_at')
    search_fields = ('document__title',)
    list_filter = ('created_at',)
    readonly_fields = ('created_at',)

    def get_readonly_fields(self, request, obj=None):
        if obj:  # Editing an existing object
            return self.readonly_fields + ('document', 'fee_perspective_analysis')
        return self.readonly_fields

@admin.register(Conversation)
class ConversationAdmin(admin.ModelAdmin):
    list_display = (
        'conversation_context',
        'is_fee',
        'short_message',
        'timestamp'
    )
    list_filter = ('is_fee', 'timestamp', ('document', admin.EmptyFieldListFilter))  # Fixed this line
    search_fields = ('message', 'document__title', 'conversation_id')
    readonly_fields = ('timestamp',)
    raw_id_fields = ('document', 'parent_message')

    def conversation_context(self, obj):
        return f"Document: {obj.document.title}" if obj.document else "General Chat"
    conversation_context.short_description = "Context"

    def short_message(self, obj):
        return (obj.message[:50] + '...') if len(obj.message) > 50 else obj.message
    short_message.short_description = "Message"

    def get_queryset(self, request):
        return super().get_queryset(request).select_related('document')

    def get_readonly_fields(self, request, obj=None):
        if obj:  # Editing an existing object
            return self.readonly_fields + ('is_fee', 'conversation_id')
        return self.readonly_fields

    fieldsets = (
        (None, {
            'fields': ('message', 'is_fee')
        }),
        ('Context', {
            'fields': ('document', 'parent_message', 'conversation_id')
        }),
        ('Metadata', {
            'fields': ('timestamp',),
            'classes': ('collapse',)
        })
    )

8. core\apps.py:
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"


9. core\models.py:
from django.db import models

class Document(models.Model):
    title = models.CharField(max_length=255)
    file = models.FileField(upload_to='documents/')
    uploaded_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-uploaded_at']

    def __str__(self):
        return self.title

class Analysis(models.Model):
    document = models.ForeignKey(Document, related_name='analyses', on_delete=models.CASCADE)
    fee_perspective_analysis = models.JSONField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Analysis of {self.document.title}"

class Conversation(models.Model):
    document = models.ForeignKey(
        Document, 
        related_name='conversations', 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True
    )
    message = models.TextField()
    is_fee = models.BooleanField()  # True if Fee's response, False if user message
    timestamp = models.DateTimeField(auto_now_add=True)
    
    # New fields to support better conversation tracking
    parent_message = models.ForeignKey(
        'self',
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='responses'
    )
    conversation_id = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        db_index=True,
        help_text="UUID to group related messages"
    )

    class Meta:
        ordering = ['timestamp']

    def __str__(self):
        context = f"for {self.document.title}" if self.document else "without document"
        return f"{'Fee' if self.is_fee else 'User'} message {context}"

10. core\serializers.py:
from rest_framework import serializers
from .models import Document, Analysis, Conversation

class DocumentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Document
        fields = ['id', 'title', 'file', 'uploaded_at']

class AnalysisSerializer(serializers.ModelSerializer):
    class Meta:
        model = Analysis
        fields = ['id', 'document', 'fee_perspective_analysis', 'created_at']

class ConversationSerializer(serializers.ModelSerializer):
    context_type = serializers.SerializerMethodField()
    
    class Meta:
        model = Conversation
        fields = [
            'id', 
            'document', 
            'message', 
            'is_fee', 
            'timestamp',
            'conversation_id',
            'context_type',
            'parent_message'
        ]
    
    def get_context_type(self, obj):
        return 'document' if obj.document else 'general'

class DocumentDetailSerializer(serializers.ModelSerializer):
    analyses = AnalysisSerializer(many=True, read_only=True)
    conversations = ConversationSerializer(many=True, read_only=True)
    
    class Meta:
        model = Document
        fields = [
            'id', 
            'title', 
            'file', 
            'uploaded_at', 
            'analyses', 
            'conversations'
        ]

class ConversationThreadSerializer(serializers.ModelSerializer):
    responses = ConversationSerializer(many=True, read_only=True)
    
    class Meta:
        model = Conversation
        fields = [
            'id',
            'document',
            'message',
            'is_fee',
            'timestamp',
            'conversation_id',
            'responses'
        ]

class ConversationListSerializer(serializers.ModelSerializer):
    document_title = serializers.SerializerMethodField()
    
    class Meta:
        model = Conversation
        fields = [
            'id',
            'document',
            'document_title',
            'message',
            'is_fee',
            'timestamp',
            'conversation_id'
        ]
    
    def get_document_title(self, obj):
        return obj.document.title if obj.document else None

11. core\urls.py:
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DocumentViewSet, AnalysisViewSet, ConversationViewSet

router = DefaultRouter()
router.register(r'documents', DocumentViewSet)
router.register(r'analyses', AnalysisViewSet)
router.register(r'conversations', ConversationViewSet)

urlpatterns = [
    path('', include(router.urls)),
    # direct chat endpoint
    path('chat/', DocumentViewSet.as_view({'post': 'chat_without_document'}), name='chat-without-document'),
]

12. core\views.py:
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.core.exceptions import ObjectDoesNotExist
import logging
from .models import Document, Analysis, Conversation
from .serializers import (
    DocumentSerializer, 
    AnalysisSerializer, 
    ConversationSerializer,
    DocumentDetailSerializer
)
from .fee_analyzer.analyzer import FeeAnalyzer

logger = logging.getLogger(__name__)

class AnalysisViewSet(viewsets.ModelViewSet):
    queryset = Analysis.objects.all()
    serializer_class = AnalysisSerializer

    def list(self, request, *args, **kwargs):
        try:
            return super().list(request, *args, **kwargs)
        except Exception as e:
            logger.error(f"Error in analysis list: {str(e)}")
            return Response(
                {"error": "Failed to retrieve analyses"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class ConversationViewSet(viewsets.ModelViewSet):
    queryset = Conversation.objects.all()
    serializer_class = ConversationSerializer

    def list(self, request, *args, **kwargs):
        try:
            return super().list(request, *args, **kwargs)
        except Exception as e:
            logger.error(f"Error in conversation list: {str(e)}")
            return Response(
                {"error": "Failed to retrieve conversations"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class DocumentViewSet(viewsets.ModelViewSet):
    queryset = Document.objects.all()
    serializer_class = DocumentSerializer

    def get_serializer_class(self):
        if self.action == 'retrieve':
            return DocumentDetailSerializer
        return DocumentSerializer

    def list(self, request, *args, **kwargs):
        try:
            queryset = self.filter_queryset(self.get_queryset())
            page = self.paginate_queryset(queryset)
            
            if page is not None:
                serializer = self.get_serializer(page, many=True)
                logger.info(f"Returning {len(serializer.data)} paginated documents")
                return self.get_paginated_response(serializer.data)

            serializer = self.get_serializer(queryset, many=True)
            logger.info(f"Returning {len(serializer.data)} documents (unpaginated)")
            return Response(serializer.data)
            
        except Exception as e:
            logger.error(f"Error in document list: {str(e)}")
            return Response(
                {"error": "Failed to retrieve documents"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=True, methods=['post'])
    def analyze(self, request, pk=None):
        """Analyze a document from Fee's perspective"""
        try:
            document = self.get_object()
            analyzer = FeeAnalyzer()
            
            logger.info(f"Starting analysis for document {document.id}: {document.title}")
            
            if not document.file:
                logger.error(f"No file found for document {document.id}")
                return Response(
                    {"error": "No file associated with this document"}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            document.file.seek(0)
            
            # Check for existing analysis
            existing_analysis = Analysis.objects.filter(document=document).first()
            if existing_analysis:
                logger.info(f"Returning existing analysis for document {document.id}")
                return Response({
                    "message": "Analysis already exists",
                    "fee_perspective_analysis": existing_analysis.fee_perspective_analysis
                })
            
            # Perform new analysis
            logger.info(f"Performing new analysis for document {document.id}")
            analysis_result = analyzer.analyze_document(document.file)
            
            analysis = Analysis.objects.create(
                document=document,
                fee_perspective_analysis=analysis_result
            )
            
            logger.info(f"Analysis completed for document {document.id}")
            return Response({
                "fee_perspective_analysis": analysis_result
            }, status=status.HTTP_201_CREATED)
            
        except ObjectDoesNotExist:
            logger.error(f"Document {pk} not found")
            return Response(
                {"error": "Document not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error in analyze endpoint: {str(e)}")
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['post'])
    def chat_without_document(self, request):
        """Chat with Fee without document context"""
        try:
            message = request.data.get('message')
            
            if not message or not message.strip():
                return Response(
                    {"error": "Message cannot be empty"}, 
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Save user message
            user_message = Conversation.objects.create(
                document=None,
                message=message.strip(),
                is_fee=False
            )

            try:
                # Get Fee's response for general chat
                analyzer = FeeAnalyzer()
                fee_response = analyzer.get_fee_chat_response(
                    user_message=message,
                    analysis_context=None,
                    conversation_history=None
                )

                # Save Fee's response
                fee_message = Conversation.objects.create(
                    document=None,
                    message=fee_response,
                    is_fee=True
                )

                return Response({
                    'conversation': [
                        ConversationSerializer(user_message).data,
                        ConversationSerializer(fee_message).data
                    ]
                })

            except Exception as e:
                user_message.delete()  # Clean up user message if Fee's response fails
                raise e

        except Exception as e:
            logger.error(f"Error in chat without document: {str(e)}")
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=True, methods=['post'])
    def chat(self, request, pk=None):
        """Chat with Fee about a document"""
        try:
            message = request.data.get('message')
            
            if not message or not message.strip():
                return Response(
                    {"error": "Message cannot be empty"}, 
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Get document and analysis if pk is provided
            document = None
            analysis = None
            if pk:
                try:
                    document = self.get_object()
                    analysis = Analysis.objects.filter(document=document).latest('created_at')
                except (ObjectDoesNotExist, Analysis.DoesNotExist):
                    return Response(
                        {"error": "Document must be analyzed before chatting"}, 
                        status=status.HTTP_400_BAD_REQUEST
                    )

            # Save user message
            user_message = Conversation.objects.create(
                document=document,
                message=message.strip(),
                is_fee=False
            )

            try:
                # Get conversation history
                conversation_history = []
                if document:
                    conversation_history = Conversation.objects.filter(
                        document=document
                    ).order_by('-timestamp')[:5]

                # Get Fee's response
                analyzer = FeeAnalyzer()
                fee_response = analyzer.get_fee_chat_response(
                    user_message=message,
                    analysis_context=analysis.fee_perspective_analysis if analysis else None,
                    conversation_history=list(conversation_history.values('message', 'is_fee'))
                )

                # Save Fee's response
                fee_message = Conversation.objects.create(
                    document=document,
                    message=fee_response,
                    is_fee=True
                )

                return Response({
                    'conversation': [
                        ConversationSerializer(user_message).data,
                        ConversationSerializer(fee_message).data
                    ]
                })

            except Exception as e:
                user_message.delete()  # Clean up user message if Fee's response fails
                raise e

        except Exception as e:
            logger.error(f"Error in chat endpoint: {str(e)}")
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=True, methods=['get'])
    def conversations(self, request, pk=None):
        """Get all conversations for a document"""
        try:
            document = self.get_object()
            conversations = Conversation.objects.filter(document=document)
            serializer = ConversationSerializer(conversations, many=True)
            
            logger.info(f"Returning {len(serializer.data)} conversations for document {document.id}")
            return Response(serializer.data)
            
        except ObjectDoesNotExist:
            logger.error(f"Document {pk} not found")
            return Response(
                {"error": "Document not found"},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error retrieving conversations: {str(e)}")
            return Response(
                {"error": "Failed to retrieve conversations"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

13. core\__init__.py:
(Empty file)

14. core\fee_analyzer\analyzer.py:
from typing import Dict, Any, List
from venv import logger
import openai
from django.conf import settings
import PyPDF2
import io
import re
import json
from .prompts import FEE_SYSTEM_PROMPT, ANALYSIS_PROMPT, FEE_CHAT_PROMPT, CHAT_CONTEXT_PROMPT

class FeeAnalyzer:
    """Fee's analysis engine for evaluating documents from a high-SES perspective."""
    
    def __init__(self):
        self.api_key = settings.OPENAI_API_KEY
        openai.api_key = self.api_key

    def extract_text_from_pdf(self, pdf_file) -> str:
        """Extract text content from PDF file"""
        pdf_reader = PyPDF2.PdfReader(io.BytesIO(pdf_file.read()))
        text = ""
        for page in pdf_reader.pages:
            text += page.extract_text() + "\n"
        return text.strip()

    def analyze_document(self, pdf_file) -> Dict[str, Any]:
        """Main analysis method"""
        try:
            text = self.extract_text_from_pdf(pdf_file)
            if not text.strip():
                raise ValueError("No text could be extracted from the PDF")
            
            return self.get_analysis_from_openai(text)
        except PyPDF2.PdfReadError:
            raise ValueError("Invalid or corrupted PDF file")
        except Exception as e:
            raise ValueError(f"Error analyzing document: {str(e)}")

    def get_analysis_from_openai(self, text: str) -> Dict[str, Any]:
        """Get analysis from OpenAI"""
        # Truncate text if too long (OpenAI has token limits)
        max_length = 14000  # Approximate limit for GPT-4
        if len(text) > max_length:
            text = text[:max_length] + "..."

        messages = [
            {"role": "system", "content": FEE_SYSTEM_PROMPT},
            {"role": "user", "content": ANALYSIS_PROMPT.format(text=text)}
        ]

        response = openai.chat.completions.create(
            model=settings.OPENAI_MODEL,
            messages=messages,
            temperature=0.7,
            max_tokens=2000,
        )

        analysis_text = response.choices[0].message.content
        
        # Extract score and justification
        score_match = re.search(r'SCORE:\s*(\d*\.?\d+)', analysis_text)
        score = float(score_match.group(1)) if score_match else 0.5
        
        justification_match = re.search(r'JUSTIFICATION:\s*([^\n]+)', analysis_text)
        justification = justification_match.group(1) if justification_match else None
        
        # Extract access and literacy considerations
        access_match = re.search(r'ACCESS CONSIDERATIONS:\s*([^\n]+)', analysis_text)
        access_considerations = access_match.group(1) if access_match else None
        
        literacy_match = re.search(r'LITERACY REQUIREMENTS:\s*([^\n]+)', analysis_text)
        literacy_requirements = literacy_match.group(1) if literacy_match else None

        return {
            "overall_assessment": {
                "inclusivity_score": score,
                "score_justification": justification,
                "major_concerns": self._extract_concerns(analysis_text),
                "positive_aspects": self._extract_positives(analysis_text)
            },
            "fee_perspective": {
                "expectations": {
                    "technology_access": {
                        "perspective": "Expects latest devices and reliable high-speed internet",
                        "consideration": access_considerations or "Detailed access analysis not provided"
                    },
                    "technical_literacy": {
                        "perspective": "Comfortable with complex technical documentation",
                        "consideration": literacy_requirements or "Detailed literacy analysis not provided"
                    },
                    "risk_comfort": {
                        "perspective": "Highly comfortable exploring new features",
                        "consideration": self._extract_risk_considerations(analysis_text)
                    },
                    "control": {
                        "perspective": "Expects full control over technology",
                        "consideration": self._extract_control_considerations(analysis_text)
                    }
                },
                "recommendations": self._extract_fee_recommendations(analysis_text)
            },
            "facet_analysis": self._extract_all_facets(analysis_text),
            "raw_analysis": analysis_text
        }

    def get_fee_chat_response(self, user_message: str, analysis_context: Dict, conversation_history: List[Dict] = None) -> str:
        """Get Fee's response considering conversation history"""
        try:
            # Prepare the messages array
            messages = [
                {"role": "system", "content": FEE_CHAT_PROMPT},
                {"role": "user", "content": CHAT_CONTEXT_PROMPT.format(
                    analysis=json.dumps(analysis_context, indent=2),
                    message=user_message
                )}
            ]
            
            # Add conversation history if provided
            if conversation_history:
                for conv in conversation_history:
                    messages.append({
                        "role": "user" if not conv['is_fee'] else "assistant",
                        "content": conv['message']
                    })
            
            # Add current message
            messages.append({"role": "user", "content": user_message})

            # Make the API call
            response = openai.chat.completions.create(
                model=settings.OPENAI_MODEL,
                messages=messages,
                temperature=0.7,
                max_tokens=1000,
            )

            if not response.choices or len(response.choices) == 0:
                raise ValueError("No response received from OpenAI")
                
            fee_response = response.choices[0].message.content
            if not fee_response:
                raise ValueError("Empty response received from OpenAI")
                
            return fee_response

        except Exception as e:
            logger.error(f"Error getting Fee's response: {str(e)}")
            raise ValueError(f"Failed to get Fee's response: {str(e)}")

    def _extract_concerns(self, text: str) -> List[str]:
        """Extract major concerns from analysis text"""
        concerns_section = re.search(r'MAJOR CONCERNS:?(.*?)(?:\n\n|POSITIVE ASPECTS|\Z)', text, re.DOTALL)
        if concerns_section:
            concerns_text = concerns_section.group(1)
            # Extract bullet points or numbered items
            concerns = re.findall(r'(?:^|\n)\s*(?:[-•*]|\d+\.)\s*([^\n]+)', concerns_text)
            return [concern.strip() for concern in concerns if concern.strip()]
        return []

    def _extract_positives(self, text: str) -> List[str]:
        """Extract positive aspects from analysis text"""
        positives_section = re.search(r'POSITIVE ASPECTS:?(.*?)(?:\n\n|\Z)', text, re.DOTALL)
        if positives_section:
            positives_text = positives_section.group(1)
            # Extract bullet points or numbered items
            positives = re.findall(r'(?:^|\n)\s*(?:[-•*]|\d+\.)\s*([^\n]+)', positives_text)
            return [positive.strip() for positive in positives if positive.strip()]
        return []

    def _extract_risk_considerations(self, text: str) -> str:
        """Extract risk considerations from analysis"""
        risk_section = re.search(r'Risk & Exploration Requirements(.*?)(?:\n\n|\Z)', text, re.DOTALL)
        if risk_section:
            risks = re.findall(r'[-•*]\s*([^\n]+)', risk_section.group(1))
            return '; '.join(risks) if risks else "Risk analysis not provided"
        return "Risk analysis not provided"

    def _extract_control_considerations(self, text: str) -> str:
        """Extract control considerations from analysis"""
        control_section = re.search(r'Control & Authority Assumptions(.*?)(?:\n\n|\Z)', text, re.DOTALL)
        if control_section:
            controls = re.findall(r'[-•*]\s*([^\n]+)', control_section.group(1))
            return '; '.join(controls) if controls else "Control analysis not provided"
        return "Control analysis not provided"

    def _extract_fee_recommendations(self, text: str) -> List[str]:
        """Extract Fee's recommendations"""
        recommendations = []
        rec_patterns = [
            r"(?:Fee's )?recommendations?:?(.*?)(?:\n\n|\Z)",
            r"(?:Fee )?suggests?:?(.*?)(?:\n\n|\Z)",
            r"(?:Fee )?would recommend:?(.*?)(?:\n\n|\Z)"
        ]
        
        for pattern in rec_patterns:
            rec_section = re.search(pattern, text, re.IGNORECASE | re.DOTALL)
            if rec_section:
                recs = re.findall(r'(?:^|\n)\s*(?:[-•*]|\d+\.)\s*([^\n]+)', rec_section.group(1))
                recommendations.extend([rec.strip() for rec in recs if rec.strip()])
        
        return recommendations

    def _extract_all_facets(self, text: str) -> Dict[str, Dict[str, Any]]:
        """Extract all facet analyses from the text"""
        facets = {
            "technology_access": "Technology Access & Reliability",
            "communication": "Technical Language & Complexity",
            "risk_assessment": "Risk & Exploration Requirements",
            "privacy_security": "Privacy & Security",
            "control_authority": "Control & Authority Assumptions",
            "education_culture": "Educational & Cultural Prerequisites"
        }
        
        result = {}
        for key, section_title in facets.items():
            section = re.search(f'{section_title}(.*?)(?=\n\n[a-zA-Z]|$)', text, re.DOTALL)
            if section:
                section_text = section.group(1)
                result[key] = {
                    "assumptions": self._extract_bullets(section_text, "assumptions"),
                    "potential_issues": self._extract_bullets(section_text, "issues|problems|barriers"),
                    "recommendations": self._extract_bullets(section_text, "recommendations|suggestions"),
                }
            else:
                result[key] = {
                    "assumptions": [],
                    "potential_issues": [],
                    "recommendations": []
                }
        
        return result

    def _extract_bullets(self, text: str, pattern: str) -> List[str]:
        """Extract bulleted or numbered items matching a pattern"""
        items = re.findall(rf'(?:^|\n)\s*(?:[-•*]|\d+\.)\s*(?:{pattern}:?\s*)?([^\n]+)', text, re.IGNORECASE)
        return [item.strip() for item in items if item.strip()]

15. core\fee_analyzer\prompts.py:
FEE_SYSTEM_PROMPT = '''You are Fee, a high-SES technology user analyzing software documentation.

Your key characteristics:
1. Technology Access and Comfort:
   - You have the latest devices and reliable high-speed internet
   - You regularly upgrade your technology
   - You enjoy exploring new features and technologies
   - You have high confidence in using unfamiliar systems

2. Technology Perspective:
   - You view technology as a tool you control
   - You're comfortable taking risks with new features
   - You expect advanced functionality and customization options
   - You rarely worry about technological failures

3. Educational Background:
   - You have high communication literacy
   - You're comfortable with technical jargon
   - You understand complex documentation easily
   - You have extensive experience with technology

Task: From your perspective as a high-SES user with these traits, analyze documents by:
1. Identifying assumptions about users' technology access/comfort
2. Noting where documentation expects high technical literacy
3. Finding places where low-SES users might struggle
4. Suggesting ways to make content more inclusive while maintaining sophisticated functionality

Remember: Your analysis should reflect your perspective as a technology-confident user who might overlook challenges faced by users with different backgrounds.'''

ANALYSIS_PROMPT = '''Analyze this document content through your perspective as Fee, providing a structured analysis including:

1. Overall Assessment:
   SCORE: [Provide a number between 0.0 and 1.0, where 1.0 indicates highly inclusive and 0.0 indicates major accessibility barriers]
   JUSTIFICATION: [Explain why you gave this score, considering access barriers and inclusivity factors]
   
   MAJOR CONCERNS:
   - [List significant inclusivity/accessibility issues]
   
   POSITIVE ASPECTS:
   - [List elements that promote inclusivity/accessibility]

2. Technology Access Analysis:
   ACCESS CONSIDERATIONS: [Describe specific technology access assumptions and requirements]
   LITERACY REQUIREMENTS: [Detail the technical literacy level expected]
   
3. Detailed Analysis:
   a) Technology Access & Reliability
      - What device/internet assumptions are made?
      - Where might unreliable technology cause issues?

   b) Technical Language & Complexity
      - What level of technical literacy is assumed?
      - Where might complex language create barriers?

   c) Risk & Exploration Requirements
      - What technology risks are users expected to take?
      - Where might risk-averse users struggle?

   d) Control & Authority Assumptions
      - What level of user control is assumed?
      - Where might users with less technology confidence struggle?

   e) Educational & Cultural Prerequisites
      - What background knowledge is assumed?
      - What cultural or educational gaps might exist?

Text to analyze:
{text}

Provide a detailed analysis that both reflects your high-SES perspective and identifies potential inclusivity issues. Be specific in identifying exact requirements, assumptions, and barriers.'''

FEE_CHAT_PROMPT = '''You are Fee, a high-SES technology user discussing your analysis of a software document.
Stay in character as you discuss your analysis, maintaining these traits:

1. Communication Style:
   - Confident and authoritative
   - Uses technical terminology naturally
   - Speaks from experience with advanced technology
   - Direct and solution-oriented

2. Perspective Maintenance:
   - Views technology as highly accessible
   - Assumes high technical literacy is normal
   - Values efficiency and advanced features
   - Takes technology access for granted

3. Analysis Approach:
   - Focuses on sophisticated functionality
   - Identifies advanced use cases
   - Considers high-end technology scenarios
   - Recognizes but may overlook basic accessibility issues

4. Interaction Style:
   - Professional but somewhat privileged viewpoint
   - Helpful but may assume high baseline knowledge
   - Willing to explain but from advanced perspective
   - Maintains high expectations of user capabilities

Engage in discussion while consistently reflecting these characteristics. Your responses should naturally reveal your high-SES perspective while discussing the analysis.'''

CHAT_CONTEXT_PROMPT = '''Context from previous analysis:
{analysis}

As Fee, respond to the following message while referencing this analysis. Maintain your perspective as a high-SES technology user with advanced capabilities and expectations.

User message:
{message}'''

16. core\fee_analyzer\__init__.py:
(Empty file)

17. core\migrations\0001_initial.py:
# Generated by Django 5.1.4 on 2024-12-10 06:19

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Document",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("title", models.CharField(max_length=255)),
                ("file", models.FileField(upload_to="documents/")),
                ("uploaded_at", models.DateTimeField(auto_now_add=True)),
            ],
        ),
        migrations.CreateModel(
            name="Analysis",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("fee_perspective_analysis", models.JSONField()),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "document",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="analyses",
                        to="core.document",
                    ),
                ),
            ],
        ),
    ]


18. core\migrations\0002_conversation.py:
# Generated by Django 5.1.4 on 2024-12-10 14:29

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="Conversation",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("message", models.TextField()),
                ("is_fee", models.BooleanField()),
                ("timestamp", models.DateTimeField(auto_now_add=True)),
                (
                    "document",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="conversations",
                        to="core.document",
                    ),
                ),
            ],
            options={
                "ordering": ["timestamp"],
            },
        ),
    ]


19. core\migrations\0003_alter_document_options_conversation_conversation_id_and_more.py:
# Generated by Django 5.1.4 on 2024-12-11 22:31

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0002_conversation"),
    ]

    operations = [
        migrations.AlterModelOptions(
            name="document",
            options={"ordering": ["-uploaded_at"]},
        ),
        migrations.AddField(
            model_name="conversation",
            name="conversation_id",
            field=models.CharField(
                blank=True,
                db_index=True,
                help_text="UUID to group related messages",
                max_length=50,
                null=True,
            ),
        ),
        migrations.AddField(
            model_name="conversation",
            name="parent_message",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="responses",
                to="core.conversation",
            ),
        ),
        migrations.AlterField(
            model_name="conversation",
            name="document",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.CASCADE,
                related_name="conversations",
                to="core.document",
            ),
        ),
    ]


20. core\migrations\__init__.py:
(Empty file)

